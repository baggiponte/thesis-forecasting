#!/usr/bin/env bash

# =================
# | EXAMPLE USAGE |
# =================

# from_excel_to_postgres path/to/zipfile1 path/to/zipfile2

# ==============================
# | DEFINE AUXILIARY FUNCTIONS |
# ==============================

_start_server_if_not_active () {

    #checks if the server is running
    if [[ "$(pg_ctl status)" == "pg_ctl: no server running" ]]; then
        echo -e "\n${BOLD}${RED}==> Postgres server is not running, starting the server...${RESET}"
        # starts the server, deletes output
        pg_ctl start -D /usr/local/var/postgres > /dev/null 2>&1
    else
        echo -e "\n${CYAN}${BOLD}==> Postgres server is already running.${RESET}"
    fi

    # lists where postgres binary and server location are
    PG_STATUS=$(pg_ctl status -D /usr/local/var/postgres | sed "s/\"//g" |  awk "NR==2")

    echo -e "\n${BOLD}${WHITE}PostgreSQL binary:${BLUE}$(echo "$PG_STATUS" | awk 'BEGIN { FS = " " } ; {print $1}')${RESET}
    ${BOLD}${WHITE}Server directory:${BLUE}$(echo "$PG_STATUS" | awk 'BEGIN { FS = " " } ; {print $3}')${RESET}"

}

_create_table_if_not_exists () {

    # define parameters
    TABLE_NAME="$1"
    DB_NAME="$2"

    echo -e "\n${BOLD}${BLUE}=>${WHITE} Checking if table ${BLUE}${TABLE_NAME}${WHITE} exists${RESET}"
    psql -c "SET datestyle TO iso, dmy;

        CREATE TABLE IF NOT EXISTS ${TABLE_NAME} (
            bici INT,
            tipo_bici VARCHAR(20),
            cliente_anonimizzato INT,
            data_prelievo TIMESTAMP,
            numero_stazione_prelievo INT,
            nome_stazione_prelievo TEXT,
            data_restituzione TIMESTAMP,
            numero_stazione_restituzione INT,
            nome_stazione_restituzione TEXT,
            distanza_totale REAL
        );" "$DB_NAME" 
    echo ""

}

_unzip_all () {

    ZIP_PATH="$1"
    EXTRACTION_DIR="$2"

    echo "${BOLD}${BLUE}=> ${WHITE}Create the extraction directory ${BLUE}${EXTRACTION_DIR}${RESET}"
    mkdir -p "$EXTRACTION_DIR"

    # unzip the file into the extraction directory
    echo -e "\n${BOLD}${BLUE}=> ${WHITE}Unzip ${BLUE}${PATH_TO_ZIP}${RESET}"
    unzip "$PATH_TO_ZIP" -d "$EXTRACTION_DIR"
    echo ""

}

_clean_headers () {

    # redefine inputs
    FILE="$1"

    # takes the header of the file and changes it to snake-case
    NEW_HEADER=$(head -1 "$FILE" | tr "[:upper:]" "[:lower:]" | tr " " "_") 

    # substitutes to the first row of the csv the newly formatted one; then outputs the file.
    # note that sed requires creating a backup file (ending with .bak): we remove it
    sed -i .bak "1s/.*/$NEW_HEADER/" "$FILE" && rm "${FILE}.bak"

}

_turn_xlsx_into_csv () {

    # redefine input(s)
    XLSX="$1"
    TEMP_CSV="${XLSX/.xlsx/_temp.csv}"

    # 1. convert the .xlsx into a _temp.csv file, then remove the .xlsx file
    echo "${BOLD}${GREEN}==> ${WHITE}Convert ${GREEN}${XLSX} ${WHITE}to ${GREEN}${TEMP_CSV}${RESET}"
    in2csv "$XLSX" > "${TEMP_CSV}" && rm "$XLSX"
    echo ""

    # 2. turn the _temp.csv header into snakecase ('Column Name' -> 'column_name')
    echo "${BOLD}${GREEN}==> ${WHITE}Clean ${GREEN}${TEMP_CSV} ${WHITE}headers${RESET}"
    _clean_headers "${TEMP_CSV}"

    # 3. selects only the columns needed
    echo "${BOLD}${GREEN}==> ${WHITE}Select the columns we need from ${GREEN}${TEMP_CSV}${RESET}"
    xsv select "1-3,5-7,10-12,15" "${TEMP_CSV}" > "${TEMP_CSV/_temp}" && rm "${TEMP_CSV}"

}

_copy_csv_into_postgres() {

    # define parameters
    CSV="$1"
    TABLE_NAME="$2"
    DB_NAME="$3"

    # store the columns of the csv as an array
    COLS="$( head -1 "$CSV" )"
    
    # copy the csv into the postgresql TABLE_NAME into the database DB_NAME
    echo "${BOLD}${CYAN}==> ${WHITE}Copying ${CYAN}${CSV} ${WHITE}to ${BLUE}${TABLE_NAME} ${WHITE}in ${VIOLET}${DB_NAME}${RESET}"
    psql -c "SET datestyle TO iso, dmy; COPY ${TABLE_NAME}(${COLS}) FROM '${CSV}' DELIMITER ',' CSV HEADER;" "$DB_NAME"

}

_zip_csvs_and_remove_dir() {

    EXEC_DIR="$1"

    # zip recursively all files in the extraction dir
    echo -e "${BOLD}${BLUE}=>${WHITE} Backing up ${BLUE}${EXEC_DIR}${RESET}"
    zip -r "${EXEC_DIR}_csv.zip" "${EXEC_DIR}" && rm -rf "$EXEC_DIR"

}

# ===============
# | SCRIPT BODY |
# ===============

# colored output "trick"
source "./formatting_colors"

# 1. define variables for postgres
# I need to reimplement this with getopt
TABLE_NAME="bikemi_rentals"
DB_NAME="bikemi"

# 2. see if the server is running 
_start_server_if_not_active

# 3. check if our target table exists, else create it
_create_table_if_not_exists "$TABLE_NAME" "$DB_NAME"

# 4. Iterate over zip files
for ZIP_PATH in "$@"; do

    # I. Unzip in a dedicated folder
    EXTRACTION_DIR="${ZIP_PATH/.zip}" 
    _unzip_all "$ZIP_PATH" "$EXTRACTION_DIR"

    # II. Temporarily cd into EXTRACTION_DIR
    pushd "$EXTRACTION_DIR" || exit

    # III. Clean filenames in EXTRACTION_DIR
    for FILE in * ; do
        echo "${BOLD}${CYAN}==> ${WHITE}Renaming ${CYAN}${FILE}${RESET}"
        rename -z "$FILE"
    done
    echo ""

    # IV. Turn .xslx files into .csvs
    for XLSX in *.xlsx ; do
        _turn_xlsx_into_csv "$XLSX"
    done

    # V. Copy .csv into postgres
    for CSV in *.csv ; do
        _copy_csv_into_postgres "$CSV" "$TABLE_NAME" "$DB_NAME"
    done

    # temporarily move up to zip the csvs and remove the directory
    pushd .. || exit

    _zip_csvs_and_remove_dir "$EXTRACTION_DIR"

    # move back to the original directory
    pushd +2 || exit
    
done
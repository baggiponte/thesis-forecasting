---
jupyter:
  jupytext:
    formats: notebooks///ipynb,notebooks_r///Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.4
  kernelspec:
    display_name: Deep Learning Forecasting
    language: python
    name: bikemi
---

<!-- #region tags=[] jp-MarkdownHeadingCollapsed=true -->
# Import Libraries and Load Data
<!-- #endregion -->

```{python init_cell=TRUE}
# Data visualisations
import matplotlib.pyplot as plt

# Base libraries
import numpy as np
import pandas as pd

# More data viz
import plotly.express as px
import seaborn as sns

# to use pandas dtypes in matplotlib plots
from pandas.plotting import register_matplotlib_converters

# rich
from rich.console import Console

# define rich console for formatted output
console = Console()

# have pandas types plotted with matplotlib
register_matplotlib_converters()

# set plotly as backend for plots wih pandas
pd.options.plotting.backend = "plotly"

# create a dict to update plotly layout
plotly_styles = dict(
    font_family="DejaVuSansMono Nerd Font",
    template="none",
    title={
        "x": 0.05,
        # basically, what part of the title to put at position "x"
        "xanchor": "left",
    },
)


# set settings for seaborn
sns.set_style(style="darkgrid", rc={"axes.facecolor": ".9", "grid.color": ".8"})
sns.set_palette(palette="deep")
sns_c = sns.color_palette(palette="deep")  # will be useful later

# visualise plots inline
# %matplotlib inline

# customise matplotlib and sns plot dimensions
plt.rcParams["figure.figsize"] = [12, 6]
plt.rcParams["figure.dpi"] = 100
```

We use `squeeze=True` to indicate that our data has only one column and we want to retrieve a `pandas.Series` (see [here](https://machinelearningmastery.com/load-explore-time-series-data-python/))

```{python}
daily_rentals = pd.read_csv(
    "../data/bikemi_csv/daily_outflow.csv",
    index_col=[0],
    parse_dates=[0],
    squeeze=True
).asfreq(freq="D") # set frequency

print(f"Our data is a {type(daily_rentals)}")

daily_rentals
```

We also need to make sure our index has a frequency - which we did with `.asfreq("D")` above:

```{python}
daily_rentals.index
```

<!-- #region jp-MarkdownHeadingCollapsed=true tags=[] -->
# Naïve forecaster
<!-- #endregion -->

We need to fit a naïve forecaster to have a benchmark for our other methods:

```{python}
from sktime.forecasting.base import ForecastingHorizon
from sktime.forecasting.model_selection import temporal_train_test_split
from sktime.forecasting.naive import NaiveForecaster
from sktime.performance_metrics.forecasting import mean_absolute_percentage_error
```

We will be using a Seasonal Naive Forecaster (link Hyndman) where the predicted value is the one of the last seasonal value (i.e., 7 days before):

```{python}
y_train, y_test = temporal_train_test_split(daily_rentals)

# uses all of the test set as forecasting horizon
fh = ForecastingHorizon(y_test.index, is_relative=False)

# naive forecaster model definition
naive_forecaster = NaiveForecaster(strategy="last", sp=7)  # weekly seasonal periodicity

# naive forecaster model fitting
naive_forecaster.fit(y_train)

# naive forecaster predictions
y_pred = naive_forecaster.predict(fh)

# naive forecaster error
naive_error = mean_absolute_percentage_error(y_test, y_pred)

print(naive_error)
```

Our model has 64% MAPE - whereas one might have expected something more. Let's plot it to see the differences:

```{python}
from sktime.utils.plotting import plot_series

plot_series(daily_rentals, y_pred, labels=["observed", "predicted"]);
```

# ARIMA Model


The autocorrelation plot suggested us to 

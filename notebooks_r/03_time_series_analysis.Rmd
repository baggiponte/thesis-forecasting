---
jupyter:
  jupytext:
    formats: notebooks///ipynb,notebooks_r///Rmd
    main_language: python
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.4
  kernelspec:
    display_name: Python 3.8.10 64-bit
    name: python3
---

# Time Series Analysis

```{python}
import pandas as pd
import plotly.express as px
pd.options.plotting.backend = "plotly"

# import custom functions
import custom_functions.time_series_analysis as tsa
import custom_functions.plot_styles as ps

ps.matplotlib_styles()
```

```{python}
df = pd.read_csv(
    "../data/bikemi_csv/daily_outflow.csv",
    parse_dates=[0],
    index_col=[0]
)

daily_outflow = ts.create_ts_features(
    df, features=["day", "week", "month", "weekends", "holidays"]
)

daily_outflow.head()
```

# Visualise the data

Let's start by looking at the time series.

```{python}
ts_plot = daily_outflow.plot(
    y="count",
    title="Daily Count of Trips in Milan",
    color_discrete_sequence=px.colors.qualitative.T10,
    labels = {
        "count": "",
        "giorno_partenza" : "date",
    }
)

ps.plotly_style(ts_plot)
```

Exploiting the `datetime` index, we can extract some new columns containing the information about the day and the month.

```{python}
hist_weekends = daily_outflow.plot.bar(
    x = daily_outflow.index,
    y = "count",
    title="Bikes Daily Outflow (2019)",
    color = "is_weekend",
    color_discrete_sequence=px.colors.qualitative.T10,
    labels = {
        "value": "Number of trips",
        "giorno_partenza" : "date",
        "is_weekend": "weekend"
    }
)

ps.plotly_style(hist_weekends)
```

```{python}
hist_holidays = daily_outflow.plot.bar(
    x = daily_outflow.index,
    y = "count",
    title="Bikes Daily Outflow (2019)",
    color = "holiday",
    color_discrete_sequence=px.colors.qualitative.T10,
    labels = {
        "count": "",
        "giorno_partenza" : ""
    }
)

ps.plotly_style(hist_holidays)
```

```{python}
# daily_outflow["months"] = [d.strftime("%b") for d in daily_outflow.index]
# daily_outflow["day"] = [d.strftime("%d") for d in daily_outflow.index]

# months = daily_outflow.index.month_name().unique()

# plt.figure()

# for month in months:
#     plt.plot(
#         "day", "count",
#         data = daily_outflow.loc[daily_outflow.index.month_name() == month, :],
#         label = month
#     )
```

The first thing that comes to mind is that the series displays a great variance. Then, there are three troughs, in correspondence of the major holidays: April with Easter, the weeks before and after August 15, and the end of the year. Clearly, the data is non-stationary. We can clearly see a trend, where the trip number increases until the middle of the year and then starts decreasing, reaching its lowest in the colder winter months. We can plot rolling means to get a better sense of these fluctuations.

```{python}
for lag in [7, 30]:
    ts.rolling_statistics(daily_outflow["count"], lags=lag, statistics = ["mean", "std"])
```

We could plot the individual values for each month to display the difference in values. However, we can show these features better with a boxplot:

```{python}
month_boxplot = ts.subunits_boxplot(daily_outflow["count"], y = "count", time_subunit = "month")

month_boxplot
```

However, the most important source of variation clearly is the weekly seasonality. The boxplot function is designed to accept various time formats, so we can adapt it pretty quickly:

```{python}
weekly_boxplot = ts.subunits_boxplot(daily_outflow["count"], y = "count", time_subunit = "weekday")

weekly_boxplot
```

```{python}
from statsmodels.tsa.seasonal import seasonal_decompose

# multiplicative decomposition

```

The results are obtained by first estimating the trend by applying a convolution filter to the data. The trend is then removed from the series and the average of this de-trended series for each period is the returned seasonal component.
